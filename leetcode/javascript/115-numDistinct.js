/**
 * 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，
 * 结果需要对 109 + 7 取模。
 */

/**
 * @description 不同的子序列
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = function(s, t) {
    const sLen = s.length;
    const tLen = t.length;

    const f = Array(sLen + 1).fill(0).map(() => Array(tLen + 1).fill(0));

    for (let i = 0; i <= sLen; ++i) {
        for (let j = 0; j <= tLen; ++j) {
            if (j === 0) {
                f[i][j] = 1; 
                continue;
            }

            if (i === 0) {
                f[i][j] = 0;
                continue;
            }

            if (s[i - 1] !== t[j - 1]) {
                f[i][j] = f[i - 1][j];
            } else {
                const index = Math.max(s.slice(0, i - 1).lastIndexOf(s[i - 1]), 0);
                f[i][j] = f[i - 1][j - 1] + f[index + 1][j];
            }
        }
    }
    
    return f[sLen][tLen];
};

/**
 * f(m, n) = f(m - 1, n) (s[m - 1] != t[n - 1])
 * f(m, n) = f(m - 1, n - 1) + f(lastIndex(0, m - 1), n) (s[m - 1] == t[n - 1])
 * 
 * f(0, 0) = 1
 * f(0, 1) = 0
 * f(1, 0) = 1
 * f(1, 1) = 1 (==)
 * f(1, 2) = 0
 * f(2, 0) = 1
 * f(2, 1) = f(1, 1) = 1
 * f(2, 2) = f(1, 1) = 1
 * f(3, 0) = 1
 * f(3, 1) = f(2, 0) + 1 = 2
 * f(3, 2) = f(2, 2) = 1
 * f(3, 3) = 0
 * f(4, 0) = 1
 * f(4, 1) = f(3, 1) = 2
 * f(4, 2) = f(3, 2) = 1
 * f(4, 3) = f(3, 2) + 0 = 1
 * f(5, 0) = 1
 * f(5, 1) = f(4, 0) + f(1, 1) + f(3, 1) = 1 + 2 = 3
 * f(5, 2) = f(4, 2) = 1
 * f(5, 3) = f(4, 3) = 1
 * f(6, 0) = 1
 * f(6, 1) = f(5, 1) = 3
 * f(6, 2) = f(5, 1) + f(2, 2) = 3 + 1 = 4
 * f(6, 3) = f(5, 3) = 1
 * f(7, 0) = 1
 * f(7, 1) = f(6, 1) = 3
 * f(7, 2) = f(6, 2) = 4
 * f(7, 3) = f(6, 2) + f(4, 3) = 4 + 1 = 5 
 */

/**
 * 测试用例：
 * console.log(numDistinct('babgbag', 'bag'))
 */

/**
 * 本题核心： 动态规划
 *
 * 反思：s与t匹配的次数分两种情况，以最后一个字符为基准，只有相同与不同，对于
 * 不同的情况，那么s[i]与s[i - 1]的次数不会因为最后一个字符发生变化，如果相同
 * 则相当于在s[i - 1]与t[j - 1]匹配次数的基础上加了个相同的字符，结果是一致的，
 * 但是还要考虑此时这个字符在s的前面也出现过，所以需要找到s对应字符倒数第一个的位
 * 置，把该位置的匹配次数也加上，共同构成总匹配次数。
 * 
 * 注意：
 * 1、当前思路在寻找除最后一位的倒数第一个字符位置时采取的方法不是很妥当，需要重复
 * 遍历，运行时间受此处影响较大。
 * 2、官方的表达式是递增式的，原理大差不差。
 * 3、有非常巧妙的降维方法，参考评论区题解，使得利用一维数组即可完成任务
 */